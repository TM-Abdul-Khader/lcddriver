/* The functions described in the following code are just a few customized Print function code for Hitachi HD44780 LCD display
   customized for my prototype "Remote Medical Assistance System". The 'print' function handles string without dealing overflow.
	 while the 'printup' function handles overflow in two modes specified my 'gate' or 'shutter'. The gate mode 
	 handles overflow by sliding sideways (like a gate) and shutter mode handles overflow by sliding upwards (like a shutter)
	 
	 Code Scripted By : TM Abdul Khader
	 Language : C                                                                                                             */


#include <reg51.h>
#define top_line 0x00
#define lower_line 0x40
#define gate 0
#define shutter 1
sbit DB7 = P1^7;
sbit DB6 = P1^6;
sbit DB5 = P1^5;
sbit DB4 = P1^4;
sbit RS = P1^3;
sbit E = P1^2;

sbit clear = P2^4;
sbit ret = P2^5;				  
sbit left = P2^6;
sbit right = P2^7;

void entry_and_overflow(bit id, bit s);
void display_switch(bit display, bit cursor, bit blinking);
void initialize_module(void);
void put_curser(char address);
void printup(char *,int);
void delay_ms(int);
void sendChar(char c);
void print(char* str);
bit bit_extract(char c, char bitNumber);
void delay(void);

void main(void) 
	{
   printup("Overflow Handler Generated by TM Abdul Khader. Streams strings of any length",gate);
  }

// LCD Module instructions -------------------------------------------
// To understand why the pins are being set to the particular values in the functions
// below, see the instruction set.
// A full explanation of the LCD Module: HD44780.pdf




void entry_and_overflow(bit id, bit s)  // First parameter for cursor (1-shift to left 0-shift to right), second one for slide overflow shifting (1 for shifting)
	{
	RS = 0;   // register select bit
	DB7 = 0;  // The four following bits are the data streaming nibbles
	DB6 = 0;
	DB5 = 0;
	DB4 = 0;
	E = 1;
	E = 0;
	DB6 = 1;
	DB5 = id;  
	DB4 = s;
	E = 1;
	E = 0;
	delay();
}

void display_switch(bit display, bit cursor, bit blinking) //On off for cursor,diaplay and blinking cursor
{
	DB7 = 0;
	DB6 = 0;
	DB5 = 0;
	DB4 = 0;
	E = 1;     // Execution bit : Initializes read or write
	E = 0;
	DB7 = 1;
	DB6 = display;
	DB5 = cursor;
	DB4 = blinking;
	E = 1;
	E = 0;
	delay();
}



void initialize_module(void)    // Function to initialize the LCD display module with 4 bit operation
{
	// The high nibble for the function set is actually sent twice. Why? See 4-bit operation
	// on pages 39 and 42 of HD44780.pdf.
	DB7 = 0;
	DB6 = 0;
	DB5 = 1;
	DB4 = 0;
	RS = 0;  // Instruction register selected
	E = 1;
	E = 0;
	delay();
	E = 1;
	E = 0;
	DB7 = 1;
	E = 1;
	E = 0;
	delay();
}
void delay_ms(int val) // delay function for printing
{
 int i=val;
 while((val--) > 0);	
}
void put_curser(char address) // used to set the cursor position
{	
	RS = 0;
	DB7 = 1;
	DB6 = bit_extract(address, 6);
	DB5 = bit_extract(address, 5);
	DB4 = bit_extract(address, 4);
	E = 1;
	E = 0;
	DB7 = bit_extract(address, 3);
	DB6 = bit_extract(address, 2);
	DB5 = bit_extract(address, 1);
	DB4 = bit_extract(address, 0);
	E = 1;
	E = 0;
	delay();
}

void sendChar(char c) {
	DB7 = bit_extract(c, 7);
	DB6 = bit_extract(c, 6);
	DB5 = bit_extract(c, 5);
	DB4 = bit_extract(c, 4);
	RS = 1;
	E = 1;
	E = 0;
	DB7 = bit_extract(c, 3);
	DB6 = bit_extract(c, 2);
	DB5 = bit_extract(c, 1);
	DB4 = bit_extract(c, 0);
	E = 1;
	E = 0;
	delay();
}

// -- End of LCD Module instructions
// --------------------------------------------------------------------

void print(char* str)   // general print function which doesnt handle overflow
{
	int index = 0;
	while (str[index] != 0) {
		sendChar(str[index]);
		index++;
	}
}

bit bit_extract(char c, char bitNumber)   // Extracting a particular bit using bit shift 
{  
	return (c >> bitNumber) & 1;
}

void delay(void) {
	char c;
	for (c = 0; c < 50; c++);
}
void printup(char *str,int ch)   // str is a very large string , ch accepts whether print should be gate or shutter 
	{

	char line1[16];
	char line2[16];
	int i,j,k,l;
	int str_length=0;
 if(ch==gate)
 {
	initialize_module();
  entry_and_overflow(1,1);
  display_switch(1,0,0);
  print(str);
 }	 
 if(ch==shutter)
 {	 
 for(i=0;str[i]!='\0';i++)
	 str_length++;
	for(i=0;i<str_length;i+=32)
	{
	 // initialize_module();
    entry_and_overflow(1,0);  // increment and no shift	  
	  display_switch(1, 0, 0);	
	  k=0;	
	  for(j=i;j<i+16;j++)
	   line1[k++]=str[j];
    k=0;
	  for(l=j;l<j+16;l++)
     line2[k++]=str[l];	
    put_curser(top_line); 		
    print(line1);
	  put_curser(lower_line); 
	  print(line2);
    delay_ms(10000);
	  put_curser(top_line);
    print("                ");
	  put_curser(lower_line); 
	  print("                ");	
   }		 
  }
 }
 


